package main

import (
	"bytes"
	"flag"
	"github.com/pkg/errors"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"regexp"
)

var (
	unsignedIntTypes = []string{
		`uint`, `uint8`, `uint16`, `uint32`, `uint64`,
		`byte`,
	}

	signedIntTypes = []string{
		`int`, `int8`, `int16`, `int32`, `int64`,
	}

	floatTypes = []string{
		`float32`, `float64`,
	}

	genHeader = []byte(`package gomath
// Code generated by 'go generate'; DO NOT EDIT

`)

	camelingRegex = regexp.MustCompile(`[0-9A-Za-z]+`)
)

var (
	argv struct {
		tmplCommonFile      string
		tmplIntFile         string
		tmplIntSignedFile   string
		tmplIntUnsignedFile string
		tmplSignedFile      string
		tmplFloatFile       string
		outFile             string
	}
)

type (
	_TYPE_     int
	_TYPENAME_ int
)

func init() {
	flag.StringVar(&argv.tmplCommonFile, `tmpl_common`, `/dev/stdin`, `Input template file (for all types)`)
	flag.StringVar(&argv.tmplIntFile, `tmpl_int`, `/dev/stdin`, `Input template file (for int types)`)
	flag.StringVar(&argv.tmplIntSignedFile, `tmpl_int_signed`, `/dev/stdin`, `Input template file (for signed int types)`)
	flag.StringVar(&argv.tmplIntUnsignedFile, `tmpl_int_unsigned`, `/dev/stdin`, `Input template file (for unsigned int types)`)
	flag.StringVar(&argv.tmplSignedFile, `tmpl_signed`, `/dev/stdin`, `Input template file (for signed types)`)
	flag.StringVar(&argv.tmplFloatFile, `tmpl_float`, `/dev/stdin`, `Input template file (for float types)`)
	flag.StringVar(&argv.outFile, `o`, `/dev/stdout`, `Output generated code file`)
}

func main() {
	log.SetPrefix(`math_gen: `)
	log.SetFlags(log.Lmicroseconds | log.Ldate | log.Lshortfile)

	flag.Parse()
	if len(argv.tmplIntSignedFile) == 0 ||
		len(argv.tmplCommonFile) == 0 ||
		len(argv.tmplIntFile) == 0 ||
		len(argv.tmplIntSignedFile) == 0 ||
		len(argv.tmplIntUnsignedFile) == 0 ||
		len(argv.tmplSignedFile) == 0 ||
		len(argv.tmplFloatFile) == 0 ||
		len(argv.outFile) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	tmplCommon, err := loadTemplate(argv.tmplCommonFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	tmplInt, err := loadTemplate(argv.tmplIntFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	tmplIntSigned, err := loadTemplate(argv.tmplIntSignedFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	tmplIntUnsigned, err := loadTemplate(argv.tmplIntUnsignedFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	tmplSigned, err := loadTemplate(argv.tmplSignedFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	tmplFloat, err := loadTemplate(argv.tmplFloatFile)
	if err != nil {
		log.Fatalln(err.Error())
	}

	outFile, err := os.Create(argv.outFile)
	if err != nil {
		log.Fatalln(`Cannot create output file: ` + err.Error())
	}
	defer outFile.Close()

	var buf bytes.Buffer

	buf.Write(genHeader)

	for _, type_ := range signedIntTypes {
		genForType(tmplCommon, []byte(type_), &buf)
		genForType(tmplInt, []byte(type_), &buf)
		genForType(tmplIntSigned, []byte(type_), &buf)
		genForType(tmplSigned, []byte(type_), &buf)
	}

	for _, type_ := range unsignedIntTypes {
		genForType(tmplCommon, []byte(type_), &buf)
		genForType(tmplInt, []byte(type_), &buf)
		genForType(tmplIntUnsigned, []byte(type_), &buf)
	}

	for _, type_ := range floatTypes {
		genForType(tmplCommon, []byte(type_), &buf)
		genForType(tmplSigned, []byte(type_), &buf)
		genForType(tmplFloat, []byte(type_), &buf)
	}

	if buf, err := format.Source(buf.Bytes()); err != nil {
		log.Fatalln(`Cannot format code: ` + err.Error())
	} else if _, err := outFile.Write(buf); err != nil {
		log.Fatalln(`Cannot write to output file: ` + err.Error())
	}
}

func loadTemplate(p string) ([]byte, error) {
	tmpl, err := ioutil.ReadFile(p)
	if err != nil {
		return nil, errors.Wrap(err, `Cannot read from input file`)
	}
	tmpl = tmpl[len("package main\n"):]
	return tmpl, nil
}

func genForType(tmpl []byte, type_ []byte, wr io.Writer) {
	typeInName := camelCase(type_)

	tmpl = bytes.Replace(tmpl, []byte(`_TYPENAME_`), typeInName, -1)
	tmpl = bytes.Replace(tmpl, []byte(`_TYPE_`), type_, -1)
	wr.Write(tmpl)
}

func camelCase(src []byte) []byte {
	chunks := camelingRegex.FindAll(bytes.ToLower(src), -1)
	for idx := range chunks {
		chunks[idx] = bytes.Title(chunks[idx])
	}
	return bytes.Join(chunks, nil)
}
